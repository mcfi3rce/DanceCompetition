* Development:
** Useful functions:
*** Transpose Function
 #+BEGIN_SRC emacs-lisp :results silent
   (defun transpose (list-of-same-size-lists)
     (apply 'mapcar* 'list list-of-same-size-lists))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp :results raw
   (let ((flipped-lists (transpose '((1 2 3) (4 5 6)))))
     (remove (second flipped-lists) flipped-lists))
 #+END_SRC

 #+RESULTS:
 ((1 4) (3 6))
 ((1 4) (3 6))
 ((1 4) (3 6))
 ((1 4) (3 6))

 #+BEGIN_SRC emacs-lisp :results value :var totals=tot1 112 2 1 3 116 117als
   (transpose totals)
 #+END_SRC

 #+RESULTS:
 | 0 | 0 | 0 | 0 | 0 | 0 | 5 | 0 |
 | 0 | 0 | 1 | 2 | 0 | 2 | 0 | 0 |
 | 1 | 1 | 1 | 0 | 2 | 0 | 0 | 0 |
 | 1 | 0 | 2 | 1 | 1 | 0 | 0 | 0 |
 | 2 | 3 | 0 | 0 | 0 | 0 | 0 | 0 |
 | 1 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |
 | 0 | 1 | 0 | 1 | 1 | 2 | 0 | 0 |

*** ++ Function:
 #+BEGIN_SRC emacs-lisp
   (defun ++ (l1 l2)
     (mapcar* '+ l1 l2))
 #+END_SRC

 #+RESULTS:
 : ++

** New way of seeing scores:
#+name: judge-score
| Judge |   1 |   2 |   3 |   4 |   5 |   6 |
| A     | 111 | 114 | 115 | 112 | 116 | 113 |
| B     | 112 | 111 |     |     |     |     |
| C     |     |     |     |     |     |     |
| D     |     |     |     |     |     |     |
| E     |     |     |     |     |     |     |

#+BEGIN_SRC emacs-lisp :var judge=judge-score
  (loop for couple in (rest (second judge))
        for place from 1 to (length (rest (second judge)))
        collect (cons place  couple))
#+END_SRC

#+RESULTS:
: ((1 . 111) (2 . 114) (3 . 115) (4 . 112) (5 . 116) (6 . 113))

** Initial values for the Dance:
 #+tblname: dances
 | Couple | 	A | 	B | 	C | 	D | 	E | 	F | 	G | 	H |
 |--------+-----+-----+-----+-----+-----+-----+-----+-----|
 |    111 |   7 |   7 |   7 |   7 |   7 |     |     |     |
 |    112 |   4 |   6 |   3 |   6 |   4 |     |     |     |
 |    113 |   1 |   5 |   2 |   3 |   5 |     |     |     |
 |    114 |   3 |   3 |   4 |   5 |   1 |     |     |     |
 |    115 |   2 |   1 |   1 |   2 |   2 |     |     |     |
 |    116 |   5 |   4 |   6 |   1 |   3 |     |     |     |
 |    117 |   6 |   2 |   5 |   4 |   6 |     |     |     |

 #+BEGIN_SRC emacs-lisp :var dances=dances :results silent
   (defun calculate-majority (row)
     (1+ (/ (length (remove-if 'stringp row)) 2)))

   (setq couples (mapcar 'first dances)
         couples-line (list couples 'hline)
         couple-scores (mapcar (lambda (row)
                                 (loop for score in (remove-if 'stringp row)
                                       collect score))
                               dances)
         majority (calculate-majority (cdr (first dances)))
         place 1)
 #+END_SRC

** Extract the place values for each of the dances:
 #+name: totals
 #+BEGIN_SRC emacs-lisp :var dances=dances :results value
   (defun extract-place (n dances)
     (mapcar (lambda (row)
               (loop for score in (remove-if 'stringp row)
                     count (= n score)))
             dances))

   (append couples-line 
           (loop for place from 1 to 8
                 collect (extract-place place dances)))
 #+END_SRC

 #+RESULTS: totals
 | 111 | 112 | 113 | 114 | 115 | 116 | 117 |
 |-----+-----+-----+-----+-----+-----+-----|
 |   0 |   0 |   1 |   1 |   2 |   1 |   0 |
 |   0 |   0 |   1 |   0 |   3 |   0 |   1 |
 |   0 |   1 |   1 |   2 |   0 |   1 |   0 |
 |   0 |   2 |   0 |   1 |   0 |   1 |   1 |
 |   0 |   0 |   2 |   1 |   0 |   1 |   1 |
 |   0 |   2 |   0 |   0 |   0 |   1 |   2 |
 |   5 |   0 |   0 |   0 |   0 |   0 |   0 |
 |   0 |   0 |   0 |   0 |   0 |   0 |   0 |

** Calculate the number of place values for each place:
 #+name: totals-row
 #+BEGIN_SRC emacs-lisp :var totals=totals
   (setq dance-totals-columns (loop with sum-row = (make-list (length (first totals)) 0)
                                    for row in (butlast totals)
                                    do (setq sum-row (++ row sum-row))
                                    collect sum-row)
         dance-totals-rows (transpose (append (list couples) dance-totals-columns)))
 #+END_SRC

 #+RESULTS: totals-row
 | 111 | 0 | 0 | 0 | 0 | 0 | 0 | 5 |
 | 112 | 0 | 0 | 1 | 3 | 3 | 5 | 5 |
 | 113 | 1 | 2 | 3 | 3 | 5 | 5 | 5 |
 | 114 | 1 | 1 | 3 | 4 | 5 | 5 | 5 |
 | 115 | 2 | 5 | 5 | 5 | 5 | 5 | 5 |
 | 116 | 1 | 1 | 2 | 3 | 4 | 5 | 5 |
 | 117 | 0 | 1 | 1 | 2 | 3 | 5 | 5 |

 #+RESULTS: totals-column
 | 111 | 0 | 0 | 0 | 0 | 0 | 0 | 5 |
 | 112 | 0 | 0 | 1 | 3 | 3 | 5 | 5 |
 | 113 | 1 | 2 | 3 | 3 | 5 | 5 | 5 |
 | 114 | 1 | 1 | 3 | 4 | 5 | 5 | 5 |
 | 115 | 2 | 5 | 5 | 5 | 5 | 5 | 5 |
 | 116 | 1 | 1 | 2 | 3 | 4 | 5 | 5 |
 | 117 | 0 | 1 | 1 | 2 | 3 | 5 | 5 |

** Find-number-of-majorities Iterative Version:
#+BEGIN_SRC emacs-lisp :results silent
  (defun find-number-of-majorities (row)
     (loop 
      for value in row
      for position from 0
      when (>= value majority) 
      collect (cons (elt couples position) value)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (find-number-of-majorities (third dance-totals-columns))
#+END_SRC

#+RESULTS:
: ((113 . 3) (114 . 3) (115 . 5))

** DONE Finds largest majority
   CLOSED: [2018-03-01 Thu 12:28]
  #+BEGIN_SRC emacs-lisp :results output
    (defun find-couples-with-largest-majority (tied-couples)
      (let ((max  (apply 'max (mapcar 'cdr tied-couples))))
        (remove-if-not (lambda (couple) (= max (cdr couple))) tied-couples)))
#+END_SRC 

#+RESULTS:
(113 114 115)
#+BEGIN_SRC emacs-lisp 
  (find-couples-with-largest-majority '((113 . 4) (114  . 4)(115 . 3))) 
#+END_SRC

#+RESULTS:
: ((113 . 4) (114 . 4))

** Remove couple after placement:
:Note:
 Adjusted the totals-column when we remove a couple
:END:

#+BEGIN_SRC emacs-lisp :results silent 
  (defun remove-couple (couple)
      (setq dance-totals-rows (remove (elt totals-row (position couple couples)) dance-totals-rows)
            dance-totals-columns (transpose dance-totals-rows)
            places (append places '(couple))))
#+END_SRC

#+BEGIN_SRC emacs-lisp  :var totals-row=totals-row
  (remove-couple 115) 
#+END_SRC

#+RESULTS:
: 2
4

 : After the couple is removed
#+BEGIN_SRC emacs-lisp :results value 
  (list couples dance-totals-rows )
#+END_SRC

#+RESULTS:
|                 111 |                 112 |                 113 |                 114 |                   1 |                 116 | 117 |
| (111 0 0 0 0 0 0 5) | (112 0 0 1 3 3 5 5) | (113 1 2 3 3 5 5 5) | (114 1 1 3 4 5 5 5) | (116 1 1 2 3 4 5 5) | (117 0 1 1 2 3 5 5) |     |

   I removed the code I was working on because I realized a test sequence of individual functions would be more informative:
   First Function:
** DONE ADD GET SCORE FOR COUPLE NUMBER
   CLOSED: [2018-02-28 Wed 17:58]
 #+BEGIN_SRC emacs-lisp :results silent
   (defun get-score (couple-number)
     (loop for row in couple-scores
           when (= (car row) couple-number)
           return (rest row)))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
   (get-score 111)
 #+END_SRC

 #+RESULTS:
 | 7 | 7 | 7 | 7 | 7 |

** DONE ADD GET SUM OF VALUES OF PLACES UNDER A CERTAIN PLACE EX: values of scores from 1-3
   CLOSED: [2018-02-28 Wed 18:05]
 #+BEGIN_SRC emacs-lisp :results silent
   (defun sum-of-values-at-place (couple place)
     (loop for value in (get-score couple)
           when (<= value place)
           sum value))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp 
   couple-scores
 #+END_SRC

 #+RESULTS:
 | 111 | 7 | 7 | 7 | 7 | 7 |
 | 112 | 4 | 6 | 3 | 6 | 4 |
 | 113 | 1 | 5 | 2 | 3 | 5 |
 | 114 | 3 | 3 | 4 | 5 | 1 |
 | 115 | 2 | 1 | 1 | 2 | 2 |
 | 116 | 5 | 4 | 6 | 1 | 3 |
 | 117 | 6 | 2 | 5 | 4 | 6 |

 #+BEGIN_SRC emacs-lisp 
   (sum-of-values-at-place 113 3)
 #+END_SRC

 #+RESULTS:
 : 6
** DONE Compare two couples and return the couple with the lowest
   CLOSED: [2018-02-28 Wed 18:43]
   compare-sums takes in two couples and a place value and returns the couple with the lowest sum.
   If the value of the sums is the same then it returns both couples 
 #+RESULTS:
 | 113 | 114 |
#+BEGIN_SRC emacs-lisp
  (defun compare-n-sums (couples place)
    ;;((113 . 3) (114 . 3) (115 . 3)
    (sort (loop for (couple . majority) in couples
                collect (cons couple (sum-of-values-at-place couple place)))
          (lambda (a b)
            (< (cdr a) (cdr b)))))
#+END_SRC

#+RESULTS:
: compare-n-sums

#+BEGIN_SRC emacs-lisp
 (compare-n-sums '((113 . 3) (114 . 3) (115 . 3)) 3)
#+END_SRC
#+RESULTS:
: ((113 . 6) (114 . 7) (115 . 8))

#+BEGIN_SRC emacs-lisp :results silent
  (defun find-winning-couples (couples)
    (loop with lowest = (cdar couples)
          for (couple . sum) in couples
          when (= lowest sum)
          collect couple))
#+END_SRC
** TODO HANDLE TIE BREAK VALUES
 #+BEGIN_SRC emacs-lisp :results silent
   (defun tie-breaker (c1 c2 place)
     ;; apply rule 6 -> largest majority
     ;; if no breaker
     ;; apply rule 7 -> sum scores lowest total wins
     ;; if no breaker both couples are deemed tied. 
     )

 #+END_SRC

** TODO Consolidate functions into one big functions
  #+BEGIN_SRC emacs-lisp :results output
    (defun single-dance ()
      (loop with dance = (cdr dance-totals-columns)
            with majority-couples = nil
            with tied-majorities = nil
            with winning-couples = nil
            for place in dance
            for place-val from 1 to (length dance)
            do (setq majority-couples (find-number-of-majorities place))
            (case (length majority-couples)
              (0)
              (1 (remove-couple (caar majority-couples)))
              (t (setq tied-majorities (find-couples-with-largest-majority majority-couples))
                 (case (length tied-majorities)
                   (1 (remove-couple (caar tied-majorities)))
                   (t (setq winning-couples (compare-n-sums tied-majorities place-val))
                      (if (= (length winning-couples) 1)
                          (remove-couple (car winning-couples)))))))))
#+END_SRC 

#+RESULTS:

#+BEGIN_SRC emacs-lisp :results output
 (single-dance)
#+END_SRC

#+BEGIN_SRC emacs-lisp
 dance-totals-rows 
#+END_SRC
#+RESULTS:
| 111 | 0 | 0 | 0 | 0 | 0 | 0 | 5 |
| 112 | 0 | 0 | 1 | 3 | 3 | 5 | 5 |
| 113 | 1 | 2 | 3 | 3 | 5 | 5 | 5 |
| 114 | 1 | 1 | 3 | 4 | 5 | 5 | 5 |
| 116 | 1 | 1 | 2 | 3 | 4 | 5 | 5 |
| 117 | 0 | 1 | 1 | 2 | 3 | 5 | 5 |

* Testing:
  *Evaluate this before testing*
** Data:
 #+tblname: dances
 | Couple | 	A | 	B | 	C | 	D | 	E | 	F | 	G | 	H |
 |--------+-----+-----+-----+-----+-----+-----+-----+-----|
 |    111 |   7 |   7 |   7 |   7 |   7 |     |     |     |
 |    112 |   4 |   6 |   3 |   6 |   4 |     |     |     |
 |    113 |   1 |   5 |   2 |   3 |   5 |     |     |     |
 |    114 |   3 |   3 |   4 |   5 |   1 |     |     |     |
 |    115 |   2 |   1 |   1 |   2 |   2 |     |     |     |
 |    116 |   5 |   4 |   6 |   1 |   3 |     |     |     |
 |    117 |   6 |   2 |   5 |   4 |   6 |     |     |     |

#+name: totals-rows
 #+BEGIN_SRC emacs-lisp :var dances=dances :results value
  (defun calculate-majority (row)
    (1+ (/ (length (remove-if 'stringp row)) 2)))
  (defun transpose (list-of-same-size-lists)
    (apply 'mapcar* 'list list-of-same-size-lists))
  (defun ++ (l1 l2)
    (mapcar* '+ l1 l2))
  (defun extract-place (n dances)
    (mapcar (lambda (row)
              (loop for score in (remove-if 'stringp row)
                    count (= n score)))
            dances))
  (setq couples (mapcar 'first dances)
        couples-line (list couples 'hline)
        couple-scores (mapcar (lambda (row)
                                (loop for score in (remove-if 'stringp row)
                                      collect score))
                              dances)
        majority (calculate-majority (cdr (first dances)))
        places ()
        totals (loop for place from 1 to 8
                     collect (extract-place place dances))
        dance-totals-columns (append (list couples)(loop with sum-row = (make-list (length (first totals)) 0)
                                                   for row in (butlast totals)
                                                   do (setq sum-row (++ row sum-row))
                                                   collect sum-row))
        dance-totals-rows (transpose dance-totals-columns)) 
 #+END_SRC

 #+RESULTS: totals-rows
 | 111 | 0 | 0 | 0 | 0 | 0 | 0 | 5 |
 | 112 | 0 | 0 | 1 | 3 | 3 | 5 | 5 |
 | 113 | 1 | 2 | 3 | 3 | 5 | 5 | 5 |
 | 114 | 1 | 1 | 3 | 4 | 5 | 5 | 5 |
 | 115 | 2 | 5 | 5 | 5 | 5 | 5 | 5 |
 | 116 | 1 | 1 | 2 | 3 | 4 | 5 | 5 |
 | 117 | 0 | 1 | 1 | 2 | 3 | 5 | 5 |

#+NAME: totals-columns
#+BEGIN_SRC elisp
  dance-totals-columns
#+END_SRC

#+RESULTS: totals-columns
| 111 | 112 | 113 | 114 | 115 | 116 | 117 |
|   0 |   0 |   1 |   1 |   2 |   1 |   0 |
|   0 |   0 |   2 |   1 |   5 |   1 |   1 |
|   0 |   1 |   3 |   3 |   5 |   2 |   1 |
|   0 |   3 |   3 |   4 |   5 |   3 |   2 |
|   0 |   3 |   5 |   5 |   5 |   4 |   3 |
|   0 |   5 |   5 |   5 |   5 |   5 |   5 |
|   5 |   5 |   5 |   5 |   5 |   5 |   5 |

  *Next evaluate the functions next*
** Functions:
#+BEGIN_SRC emacs-lisp :results silent 
  (defun find-number-of-majorities (row)
    (loop 
     for value in row
     for position from 0
     when (>= value majority) 
     collect (cons (elt couples position) value)))

  (defun position-to-couples (tied-couples)
    (mapcar (lambda (x) (elt couples (car x))) tied-couples))

  (defun find-couples-with-largest-majority (tied-couples)
    (let ((max  (apply 'max (mapcar 'cdr tied-couples))))
      (remove-if-not (lambda (couple) (= max (cdr couple))) tied-couples)))

  (defun remove-couple (couple)
    (if (> (length dance-totals-rows) 1)
        (setq dance-totals-rows (remove (assoc couple dance-totals-rows) dance-totals-rows)
              dance-totals-columns (transpose dance-totals-rows)
              couples (remove couple couples)
              places (append places (list couple)))
      ;; removing the last element causes issues
      (setq dance-totals-rows nil
            couples nil
            places (append places (list couple))
            )))

  (defun get-score (couple-number)
    (loop for row in couple-scores
          when (= (car row) couple-number)
          return (rest row)))

  (defun sum-of-values-at-place (couple place)
    (loop for value in (get-score couple)
          when (<= value place)
          sum value))

(defun compare-n-sums (couples place)
    ;;((113 . 3) (114 . 3) (115 . 3)
    (sort (loop for (couple . majority) in couples
                collect (cons couple (sum-of-values-at-place couple place)))
          (lambda (a b)
            (< (cdr a) (cdr b)))))

  (defun print-standings (standings)
     (loop for couple in standings
          for place from 1 to (length standings)
          collect (list place couple)))
 #+END_SRC 
#+END_SRC
** Testing:
  : This will follow the way the final code will be evaluated:
*** Step 1: Find the couple with the largest majority
   #+BEGIN_SRC emacs-lisp 
     (loop for row in (cdr dance-totals-columns)
           collect (find-number-of-majorities row))
#+END_SRC 

#+RESULTS:
| (115 . 5) |           |           |           |           |           |           |
| (113 . 3) | (114 . 3) | (115 . 5) |           |           |           |           |
| (112 . 3) | (113 . 3) | (114 . 4) | (115 . 5) | (116 . 3) |           |           |
| (112 . 3) | (113 . 5) | (114 . 5) | (115 . 5) | (116 . 4) | (117 . 3) |           |
| (112 . 5) | (113 . 5) | (114 . 5) | (115 . 5) | (116 . 5) | (117 . 5) |           |
| (111 . 5) | (112 . 5) | (113 . 5) | (114 . 5) | (115 . 5) | (116 . 5) | (117 . 5) |
   
*** Step 2: If there is only one couple then remove that couple
   #+BEGIN_SRC emacs-lisp 
     (remove-couple 115)
   #+END_SRC

   #+RESULTS:
   | 115 |

*** Step 3: Find the next couple with the largest majority
#+BEGIN_SRC emacs-lisp 
      (loop for row in (rest dance-totals-columns)
            collect (find-number-of-majorities row))
#+END_SRC 

#+RESULTS:
| (113 . 3) | (114 . 3) |           |           |           |           |
| (112 . 3) | (113 . 3) | (114 . 4) | (116 . 3) |           |           |
| (112 . 3) | (113 . 5) | (114 . 5) | (116 . 4) | (117 . 3) |           |
| (112 . 5) | (113 . 5) | (114 . 5) | (116 . 5) | (117 . 5) |           |
| (111 . 5) | (112 . 5) | (113 . 5) | (114 . 5) | (116 . 5) | (117 . 5) |

*** Step 4: Find next majority
  #+BEGIN_SRC emacs-lisp
    (find-couples-with-largest-majority '((113 . 3)(114 . 3)))
#+END_SRC 

#+RESULTS:
: ((113 . 3) (114 . 3))
   
*** Tiebreak #1: If there is no higher majority sum the values
  #+BEGIN_SRC emacs-lisp
    (compare-sums 113 114 3)
#+END_SRC 

#+RESULTS:
: 113

#+BEGIN_SRC emacs-lisp 
  (remove-couple 113) 
#+END_SRC

#+RESULTS:
| 115 | 113 |

#+BEGIN_SRC emacs-lisp 
 (remove-couple 114)  
#+END_SRC

#+RESULTS:
| 115 | 113 | 114 |

: 2
*** Step 6: Find next majority
#+BEGIN_SRC emacs-lisp 
      (loop for row in (cdr dance-totals-columns)
            collect (find-number-of-majorities row))
#+END_SRC

#+RESULTS:
| (112 . 3) | (116 . 3) |           |           |
| (112 . 3) | (116 . 4) | (117 . 3) |           |
| (112 . 5) | (116 . 5) | (117 . 5) |           |
| (111 . 5) | (112 . 5) | (116 . 5) | (117 . 5) |

*** Step 7: Since both couples have the same majority
   #+BEGIN_SRC emacs-lisp
     (compare-sums 112 116 4)
#+END_SRC 

#+RESULTS:
: 116

*** Step 8: Remove couples with Majority
#+BEGIN_SRC emacs-lisp 
 (remove-couple 116)  
#+END_SRC

#+RESULTS:
| 115 | 113 | 114 | 116 |

#+BEGIN_SRC emacs-lisp 
 (remove-couple 112)  
#+END_SRC

#+RESULTS:
| 115 | 113 | 114 | 116 | 112 |
*** Step 9: Find Next Majority
#+BEGIN_SRC emacs-lisp 
      (loop for row in (cdr dance-totals-columns)
            collect (find-number-of-majorities row))
#+END_SRC

#+RESULTS:
| (117 . 3) |           |
| (117 . 5) |           |
| (111 . 5) | (117 . 5) |

*** Step 10: Single Majority
#+BEGIN_SRC emacs-lisp 
 (remove-couple 117)  
#+END_SRC

#+RESULTS:
| 115 | 113 | 114 | 116 | 112 | 117 |

*** Step 12: Find LAST MAJORITY
#+BEGIN_SRC emacs-lisp 
      (loop for row in (cdr dance-totals-columns)
            collect (find-number-of-majorities row))
#+END_SRC

#+RESULTS:
| (111 . 5) |

#+BEGIN_SRC emacs-lisp 
 (remove-couple 111)  
#+END_SRC

#+RESULTS:
| 115 | 113 | 114 | 116 | 112 | 117 | 111 |

*** Step 13: Print Scores
   #+BEGIN_SRC emacs-lisp
   (print-standings places)
#+END_SRC 

#+RESULTS:
| 1 | 115 |
| 2 | 113 |
| 3 | 114 |
| 4 | 116 |
| 5 | 112 |
| 6 | 117 |
| 7 | 111 |

*** Test UI
  Judges:
  [ ] 3
  [x] 5
  [ ] 7
  [ ] 9

  #+name: couple-number
  6
 
  #+name: number-of-dances
  5

**** Dance 1: Cha-Cha


   #+name: d
   | Number of Dances | 5 |   |
   | Random text      |   |   |
   
   #+BEGIN_SRC elisp :var d=d  
   (loop for x from 1 to (cadr (first d))
           collect d)
   #+END_SRC

   #+RESULTS:
   | (Number of Dances 5 ) | (Random text  ) |
   | (Number of Dances 5 ) | (Random text  ) |
   | (Number of Dances 5 ) | (Random text  ) |
   | (Number of Dances 5 ) | (Random text  ) |
   | (Number of Dances 5 ) | (Random text  ) |
** Beginning of the 
