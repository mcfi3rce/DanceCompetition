* Development:
** Useful functions:
*** Transpose Function
**** Rotates the tables horizonal and verticle. 
 #+BEGIN_SRC emacs-lisp :results silent
   (defun transpose (list-of-same-size-lists)
     (apply 'mapcar* 'list list-of-same-size-lists))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp :results raw
   (let ((flipped-lists (transpose '((1 2 3) (4 5 6)))))
     (remove (second flipped-lists) flipped-lists))
 #+END_SRC

 #+RESULTS:
 ((1 4) (3 6))
 ((1 4) (3 6))
 ((1 4) (3 6))
 ((1 4) (3 6))

 #+BEGIN_SRC emacs-lisp :results value :var totals=tot1 112 2 1 3 116 117als
   (transpose totals)
 #+END_SRC

 #+RESULTS:
 | 0 | 0 | 0 | 0 | 0 | 0 | 5 | 0 |
 | 0 | 0 | 1 | 2 | 0 | 2 | 0 | 0 |
 | 1 | 1 | 1 | 0 | 2 | 0 | 0 | 0 |
 | 1 | 0 | 2 | 1 | 1 | 0 | 0 | 0 |
 | 2 | 3 | 0 | 0 | 0 | 0 | 0 | 0 |
 | 1 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |
 | 0 | 1 | 0 | 1 | 1 | 2 | 0 | 0 |

*** ++ Function:
**** Takes in two lists and adds them together
 #+BEGIN_SRC emacs-lisp
   (defun ++ (l1 l2)
     (mapcar* '+ l1 l2))
 #+END_SRC

 #+RESULTS:
 : ++

** TODO New way of seeing scores:
#+name: judge-score
| Judge |   1 |   2 |   3 |   4 |   5 |   6 |
| A     | 111 | 114 | 115 | 112 | 116 | 113 |
| B     | 112 | 111 |     |     |     |     |
| C     |     |     |     |     |     |     |
| D     |     |     |     |     |     |     |
| E     |     |     |     |     |     |     |

#+BEGIN_SRC emacs-lisp :var judge=judge-score
  (loop for couple in (rest (second judge))
        for place from 1 to (length (rest (second judge)))
        collect (cons place  couple))
#+END_SRC

#+RESULTS:
: ((1 . 111) (2 . 114) (3 . 115) (4 . 112) (5 . 116) (6 . 113))

** Initial values for the Dance:
 #+tblname: dances
 | Couple | 	A | 	B | 	C | 	D | 	E | 	F | 	G | 	H |
 |--------+-----+-----+-----+-----+-----+-----+-----+-----|
 |    111 |   7 |   7 |   7 |   7 |   7 |     |     |     |
 |    112 |   4 |   6 |   3 |   6 |   4 |     |     |     |
 |    113 |   1 |   5 |   2 |   3 |   5 |     |     |     |
 |    114 |   3 |   3 |   4 |   5 |   1 |     |     |     |
 |    115 |   2 |   1 |   1 |   2 |   2 |     |     |     |
 |    116 |   5 |   4 |   6 |   1 |   3 |     |     |     |
 |    117 |   6 |   2 |   5 |   4 |   6 |     |     |     |

 #+BEGIN_SRC emacs-lisp :var dances=dances :results silent
   (defun calculate-majority (row)
     (1+ (/ (length (remove-if 'stringp row)) 2)))

   (setq couples (mapcar 'first dances)
         couples-line (list couples 'hline)
         couple-scores (mapcar (lambda (row)
                                 (loop for score in (remove-if 'stringp row)
                                       collect score))
                               dances)
         majority (calculate-majority (cdr (first dances)))
         place 1)
 #+END_SRC

** Extract the place values for each of the dances:
 #+name: totals
 #+BEGIN_SRC emacs-lisp :var dances=dances :results value
   (defun extract-place (n dances)
     (mapcar (lambda (row)
               (loop for score in (remove-if 'stringp row)
                     count (= n score)))
             dances))

   (append couples-line 
           (loop for place from 1 to 8
                 collect (extract-place place dances)))
 #+END_SRC

 #+RESULTS: totals
 | 111 | 112 | 113 | 114 | 115 | 116 | 117 |
 |-----+-----+-----+-----+-----+-----+-----|
 |   0 |   0 |   1 |   1 |   2 |   1 |   0 |
 |   0 |   0 |   1 |   0 |   3 |   0 |   1 |
 |   0 |   1 |   1 |   2 |   0 |   1 |   0 |
 |   0 |   2 |   0 |   1 |   0 |   1 |   1 |
 |   0 |   0 |   2 |   1 |   0 |   1 |   1 |
 |   0 |   2 |   0 |   0 |   0 |   1 |   2 |
 |   5 |   0 |   0 |   0 |   0 |   0 |   0 |
 |   0 |   0 |   0 |   0 |   0 |   0 |   0 |

** Calculate the number of place values for each place:
 #+name: totals-row
 #+BEGIN_SRC emacs-lisp :var totals=totals
   (setq dance-totals-columns (loop with sum-row = (make-list (length (first totals)) 0)
                                    for row in (butlast totals)
                                    do (setq sum-row (++ row sum-row))
                                    collect sum-row)
         dance-totals-rows (transpose (append (list couples) dance-totals-columns)))
 #+END_SRC

 #+RESULTS: totals-row
 | 111 | 0 | 0 | 0 | 0 | 0 | 0 | 5 |
 | 112 | 0 | 0 | 1 | 3 | 3 | 5 | 5 |
 | 113 | 1 | 2 | 3 | 3 | 5 | 5 | 5 |
 | 114 | 1 | 1 | 3 | 4 | 5 | 5 | 5 |
 | 115 | 2 | 5 | 5 | 5 | 5 | 5 | 5 |
 | 116 | 1 | 1 | 2 | 3 | 4 | 5 | 5 |
 | 117 | 0 | 1 | 1 | 2 | 3 | 5 | 5 |

 #+RESULTS: totals-column
 | 111 | 0 | 0 | 0 | 0 | 0 | 0 | 5 |
 | 112 | 0 | 0 | 1 | 3 | 3 | 5 | 5 |
 | 113 | 1 | 2 | 3 | 3 | 5 | 5 | 5 |
 | 114 | 1 | 1 | 3 | 4 | 5 | 5 | 5 |
 | 115 | 2 | 5 | 5 | 5 | 5 | 5 | 5 |
 | 116 | 1 | 1 | 2 | 3 | 4 | 5 | 5 |
 | 117 | 0 | 1 | 1 | 2 | 3 | 5 | 5 |

** Find-number-of-majorities Iterative Version:
#+BEGIN_SRC emacs-lisp :results silent
  (defun find-number-of-majorities (row couples)
     (loop 
      for value in row
      for position from 0
      when (>= value majority) 
      collect (cons (elt couples position) value)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (find-number-of-majorities (third dance-totals-columns))
#+END_SRC

#+RESULTS:
: ((113 . 3) (114 . 3) (115 . 5))

** TODO Finds largest majority
:possible-bug:
We don't know if this will handle the couple who still has a majority
:END:
  #+BEGIN_SRC emacs-lisp :results output
    (defun find-couples-with-largest-majority (tied-couples)
      (let ((max  (apply 'max (mapcar 'cdr tied-couples))))
        (remove-if-not (lambda (couple) (= max (cdr couple))) tied-couples)))
#+END_SRC 

#+RESULTS:
(113 114 115)
#+BEGIN_SRC emacs-lisp 
  (find-couples-with-largest-majority '((113 . 4) (114  . 4)(115 . 3))) 
#+END_SRC

#+RESULTS:
: ((113 . 4) (114 . 4))

** DONE Remove couples after placement:
   CLOSED: [2018-03-08 Thu 12:53]
:Note:
 Adjusted the totals-column when we remove a couple
:END:
#+BEGIN_SRC emacs-lisp
  (defun remove-couples (couples rows)
   (mapcar (lambda (couple) (setq rows (remove-couple couple rows))) (mapcar 'car couples))(transpose rows))
#+END_SRC

#+RESULTS:
: remove-couples

#+BEGIN_SRC emacs-lisp :results raw
  (setq test '((113 . 3)(114 . 3)(115 . 3))) 
  (setq last (remove-couples test dance-totals-rows))
  last
#+END_SRC

#+RESULTS:
((111 112 116 117) (0 0 1 0) (0 0 1 1) (0 1 2 1) (0 3 3 2) (0 3 4 3) (0 5 5 5) (5 5 5 5))
((111 0 0 0 0 0 0 5) (112 0 0 1 3 3 5 5) (116 1 1 2 3 4 5 5) (117 0 1 1 2 3 5 5))
** DONE remove couples non-global 
   CLOSED: [2018-03-08 Thu 12:53]
#+BEGIN_SRC emacs-lisp
  (defun remove-couple (couple-num rows)
    (if (> (length rows) 1)
        (setq couples (remove couple-num couples)
              places (append places (list couple-num))
              rows (remove (assoc couple-num dance-totals-rows) rows))
      ;; removing the last element causes issues
      (setq couples (remove couple-num couples)
            places (append places (list couple-num))
            rows nil))(transpose rows))
#+END_SRC

#+RESULTS:
: remove-couple

 : After the couple is removed
#+BEGIN_SRC emacs-lisp :results value 
  (list couples dance-totals-rows )
#+END_SRC

#+RESULTS:
|                 111 |                 112 |                 113 |                 114 |                   1 |                 116 | 117 |
| (111 0 0 0 0 0 0 5) | (112 0 0 1 3 3 5 5) | (113 1 2 3 3 5 5 5) | (114 1 1 3 4 5 5 5) | (116 1 1 2 3 4 5 5) | (117 0 1 1 2 3 5 5) |     |

   I removed the code I was working on because I realized a test sequence of individual functions would be more informative:
   First Function:
** ADD GET SCORE FOR COUPLE NUMBER
 #+BEGIN_SRC emacs-lisp :results silent
   (defun get-score (couple-number)
     (loop for row in couple-scores
           when (= (car row) couple-number)
           return (rest row)))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
   (get-score 111)
 #+END_SRC

 #+RESULTS:
 | 7 | 7 | 7 | 7 | 7 |

** ADD GET SUM OF VALUES OF PLACES UNDER A CERTAIN PLACE EX: values of scores from 1-3
 #+BEGIN_SRC emacs-lisp :results silent
   (defun sum-of-values-at-place (couple place)
     (loop for value in (get-score couple)
           when (<= value place)
           sum value))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp 
   couple-scores
 #+END_SRC

 #+RESULTS:
 | 111 | 7 | 7 | 7 | 7 | 7 |
 | 112 | 4 | 6 | 3 | 6 | 4 |
 | 113 | 1 | 5 | 2 | 3 | 5 |
 | 114 | 3 | 3 | 4 | 5 | 1 |
 | 115 | 2 | 1 | 1 | 2 | 2 |
 | 116 | 5 | 4 | 6 | 1 | 3 |
 | 117 | 6 | 2 | 5 | 4 | 6 |

 #+BEGIN_SRC emacs-lisp 
   (sum-of-values-at-place 113 3)
 #+END_SRC

 #+RESULTS:
 : 6
** Compare two couples and return the couple with the lowest
   compare-sums takes in two couples and a place value and returns the couple with the lowest sum.
   If the value of the sums is the same then it returns both couples 
 #+RESULTS:
 | 113 | 114 |
#+BEGIN_SRC emacs-lisp
  (defun compare-n-sums (couples place)
    ;;((113 . 3) (114 . 3) (115 . 3)
    (sort (loop for (couple . majority) in couples
                collect (cons couple (sum-of-values-at-place couple place)))
          (lambda (a b)
            (< (cdr a) (cdr b)))))
#+END_SRC

#+RESULTS:
: compare-n-sums

#+BEGIN_SRC emacs-lisp
 (compare-n-sums '((113 . 3) (114 . 3) (115 . 3)) 3)
#+END_SRC
#+RESULTS:
: ((113 . 6) (114 . 7) (115 . 8))

#+BEGIN_SRC emacs-lisp :results silent
  (defun find-winning-couples (couples)
    (loop with lowest = (cdar couples)
          for (couple . sum) in couples
          when (= lowest sum)
          collect couple))
#+END_SRC
** TODO Hande removing all the couples that have a majority
** TODO Handle tied sums to the end
#+BEGIN_SRC emacs-lisp
  (defun really-tied (tied-couples place)
    (loop for couple-1 in tied-couples
          for couple-2 in (rest couples)
          if (< (cdr couple-1)(cdr couple-2))
          (remove-couples tied-couples)
          if (-all-p (lambda (x) (= x (cdr couple-1))) tied-couples)
          (single-dance (filter-columns tied-couples dance-totals-columns))))
#+END_SRC

#+RESULTS:
: really-tied

** TODO Consolidate functions into one big function
   : We need this to be able to handle the case when couples are tied all the way
  #+BEGIN_SRC emacs-lisp :results output 
    (defun single-dance (dance-columns)
          (loop with dance = (cdr dance-columns)
                with majority-couples = nil
                with tied-majorities = nil
                with winning-couples = nil
                for place in dance
                for place-val from 1 to (length dance)
                do
                ;; (debug)
                (setq majority-couples (find-number-of-majorities place couples))
                ;; (debug)
                (case (length majority-couples)
                  (0)
                  (1 (setq dance (remove-couple (caar majority-couples) dance)))
                  (t (setq tied-majorities (find-couples-with-largest-majority majority-couples))
                     (case (length tied-majorities)
                       (1 (setq dance (remove-couple (caar tied-majorities) dance)))
                       (t (setq winning-couples (compare-n-sums tied-majorities place-val))
                          (really-tied winning-couples place)))))))






          (defun multi-dance()
            ;; gather number of judges
            ;; gather number of couples
            ;; gather number of dances
            ;;
            ;; create table according to specs
            ;; allow the judges to enter score rankings per couple on that particular dance.
            ;; repeat until all dances have been completed
            ;; begin rankings and apply rules 5 - 11
            ;; if there is a tie -> call tie breaker function
            ;; display final summary table and provide final score and ranks
            ) 
#+END_SRC 

#+RESULTS:

#+BEGIN_SRC emacs-lisp :results output
  (single-dance dance-totals-columns)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
 dance-totals-columns 
#+END_SRC
#+RESULTS:
| 111 | 112 | 113 | 114 | 115 | 116 | 117 |
|   0 |   0 |   1 |   1 |   2 |   1 |   0 |
|   0 |   0 |   2 |   1 |   5 |   1 |   1 |
|   0 |   1 |   3 |   3 |   5 |   2 |   1 |
|   0 |   3 |   3 |   4 |   5 |   3 |   2 |
|   0 |   3 |   5 |   5 |   5 |   4 |   3 |
|   0 |   5 |   5 |   5 |   5 |   5 |   5 |
|   5 |   5 |   5 |   5 |   5 |   5 |   5 |

** Filter columns 
#+BEGIN_SRC emacs-lisp
  (defun filter-columns (filter-couples columns)
    (let ((edited (transpose columns)))
      (loop
       for (couple . sum) in filter-couples
       do (setq edited (remove (assoc couple edited) edited)))(transpose edited)))
#+END_SRC

#+RESULTS:
: filter-columns

* Testing:
  *Evaluate this before testing*
** Data:
 #+tblname: dances
 | Couple | 	A | 	B | 	C | 	D | 	E | 	F | 	G | 	H |
 |--------+-----+-----+-----+-----+-----+-----+-----+-----|
 |    111 |   7 |   7 |   7 |   7 |   7 |     |     |     |
 |    112 |   4 |   6 |   3 |   6 |   4 |     |     |     |
 |    113 |   1 |   5 |   2 |   3 |   5 |     |     |     |
 |    114 |   3 |   3 |   4 |   5 |   1 |     |     |     |
 |    115 |   2 |   1 |   1 |   2 |   2 |     |     |     |
 |    116 |   5 |   4 |   6 |   1 |   3 |     |     |     |
 |    117 |   6 |   2 |   5 |   4 |   6 |     |     |     |

#+name: totals-rows
 #+BEGIN_SRC emacs-lisp :var dances=dances :results value
  (defun calculate-majority (row)
    (1+ (/ (length (remove-if 'stringp row)) 2)))
  
  (defun transpose (list-of-same-size-lists)
    (apply 'mapcar* 'list list-of-same-size-lists))
  
  (defun ++ (l1 l2)
    (mapcar* '+ l1 l2))
  
  (defun extract-place (n dances)
    (mapcar (lambda (row)
              (loop for score in (remove-if 'stringp row)
                    count (= n score)))
            dances))
  (setq couples (mapcar 'first dances)
        couples-line (list couples 'hline)
        couple-scores (mapcar (lambda (row)
                                (loop for score in (remove-if 'stringp row)
                                      collect score))
                              dances)
        majority (calculate-majority (cdr (first dances)))
        places ()
        totals (loop for place from 1 to 8
                     collect (extract-place place dances))
        dance-totals-columns (append (list couples)(loop with sum-row = (make-list (length (first totals)) 0)
                                                   for row in (butlast totals)
                                                   do (setq sum-row (++ row sum-row))
                                                   collect sum-row))
        dance-totals-rows (transpose dance-totals-columns)) 
 #+END_SRC

 #+RESULTS: totals-rows
 | 111 | 0 | 0 | 0 | 0 | 0 | 0 | 5 |
 | 112 | 0 | 0 | 1 | 3 | 3 | 5 | 5 |
 | 113 | 1 | 2 | 3 | 3 | 5 | 5 | 5 |
 | 114 | 1 | 1 | 3 | 4 | 5 | 5 | 5 |
 | 115 | 2 | 5 | 5 | 5 | 5 | 5 | 5 |
 | 116 | 1 | 1 | 2 | 3 | 4 | 5 | 5 |
 | 117 | 0 | 1 | 1 | 2 | 3 | 5 | 5 |

#+NAME: totals-columns
#+BEGIN_SRC elisp
  dance-totals-columns
#+END_SRC

#+RESULTS: totals-columns
| 111 | 112 | 113 | 114 | 115 | 116 | 117 |
|   0 |   0 |   1 |   1 |   2 |   1 |   0 |
|   0 |   0 |   2 |   1 |   5 |   1 |   1 |
|   0 |   1 |   3 |   3 |   5 |   2 |   1 |
|   0 |   3 |   3 |   4 |   5 |   3 |   2 |
|   0 |   3 |   5 |   5 |   5 |   4 |   3 |
|   0 |   5 |   5 |   5 |   5 |   5 |   5 |
|   5 |   5 |   5 |   5 |   5 |   5 |   5 |

  *Next evaluate the functions next*
** Functions:
#+BEGIN_SRC emacs-lisp :results silent 
  (defun find-number-of-majorities (row couples)
    (loop 
     for value in row
     for position from 0
     when (>= value majority) 
     collect (cons (elt couples position) value)))

  (defun position-to-couples (tied-couples)
    (mapcar (lambda (x) (elt couples (car x))) tied-couples))

  (defun find-couples-with-largest-majority (tied-couples)
    (let ((max  (apply 'max (mapcar 'cdr tied-couples))))
      (remove-if-not (lambda (couple) (= max (cdr couple))) tied-couples)))

  (defun remove-couple (couple-num rows)
    (if (> (length rows) 1)
        (setq couples (remove couple-num couples)
                    places (append places (list couple-num))
                    rows (remove (assoc couple-num dance-totals-rows) rows))
      ;; removing the last element causes issues
      (setq couples (remove couple-num couples)
            places (append places (list couple-num))
            rows nil))(transpose rows))

  (defun get-score (couple-number)
    (loop for row in couple-scores
          when (= (car row) couple-number)
            return (rest row)))

  (defun sum-of-values-at-place (couple place)
    (loop for value in (get-score couple)
          when (<= value place)
          sum value))

  (defun compare-n-sums (couples place)
    ;;((113 . 3) (114 . 3) (115 . 3)
    (sort (loop for (couple . majority) in couples
                collect (cons couple (sum-of-values-at-place couple place)))
          (lambda (a b)
            (< (cdr a) (cdr b)))))

  (defun print-standings (standings)
    (loop for couple in standings
          for place from 1 to (length standings)
          collect (list place couple)))
 #+END_SRC 
** Testing:
   : This will follow the way the final code will be evaluated:
*** Step 1: Find the couple with the largest majority
**** couple 115 has a majority of 5
   #+BEGIN_SRC emacs-lisp 
     (loop for row in (cdr dance-totals-columns)
           collect (find-number-of-majorities row))
#+END_SRC 

#+RESULTS:
| (115 . 5) |           |           |           |           |           |           |
| (113 . 3) | (114 . 3) | (115 . 5) |           |           |           |           |
| (112 . 3) | (113 . 3) | (114 . 4) | (115 . 5) | (116 . 3) |           |           |
| (112 . 3) | (113 . 5) | (114 . 5) | (115 . 5) | (116 . 4) | (117 . 3) |           |
| (112 . 5) | (113 . 5) | (114 . 5) | (115 . 5) | (116 . 5) | (117 . 5) |           |
| (111 . 5) | (112 . 5) | (113 . 5) | (114 . 5) | (115 . 5) | (116 . 5) | (117 . 5) |
   
*** Step 2: If there is only one couple then remove that couple
   #+BEGIN_SRC emacs-lisp 
     (remove-couple 115)
   #+END_SRC

   #+RESULTS:
   | 115 |

*** Step 3: Find the next couple with the largest majority
#+BEGIN_SRC emacs-lisp 
      (loop for row in (rest dance-totals-columns)
            collect (find-number-of-majorities row))
#+END_SRC 

#+RESULTS:
| (113 . 3) | (114 . 3) |           |           |           |           |
| (112 . 3) | (113 . 3) | (114 . 4) | (116 . 3) |           |           |
| (112 . 3) | (113 . 5) | (114 . 5) | (116 . 4) | (117 . 3) |           |
| (112 . 5) | (113 . 5) | (114 . 5) | (116 . 5) | (117 . 5) |           |
| (111 . 5) | (112 . 5) | (113 . 5) | (114 . 5) | (116 . 5) | (117 . 5) |

*** Step 4: Find next majority
  #+BEGIN_SRC emacs-lisp
    (find-couples-with-largest-majority '((113 . 3)(114 . 3)))
#+END_SRC 

#+RESULTS:
: ((113 . 3) (114 . 3))
   
*** Tiebreak #1: If there is no higher majority sum the values
  #+BEGIN_SRC emacs-lisp
    (compare-sums 113 114 3)
#+END_SRC 

#+RESULTS:
: 113

#+BEGIN_SRC emacs-lisp 
  (remove-couple 113) 
#+END_SRC

#+RESULTS:
| 115 | 113 |

#+BEGIN_SRC emacs-lisp 
 (remove-couple 114)  
#+END_SRC

#+RESULTS:
| 115 | 113 | 114 |

: 2
*** Step 6: Find next majority
#+BEGIN_SRC emacs-lisp 
      (loop for row in (cdr dance-totals-columns)
            collect (find-number-of-majorities row))
#+END_SRC

#+RESULTS:
| (112 . 3) | (116 . 3) |           |           |
| (112 . 3) | (116 . 4) | (117 . 3) |           |
| (112 . 5) | (116 . 5) | (117 . 5) |           |
| (111 . 5) | (112 . 5) | (116 . 5) | (117 . 5) |

*** Step 7: Since both couples have the same majority
   #+BEGIN_SRC emacs-lisp
     (compare-sums 112 116 4)
#+END_SRC 

#+RESULTS:
: 116

*** Step 8: Remove couples with Majority
#+BEGIN_SRC emacs-lisp 
 (remove-couple 116)  
#+END_SRC

#+RESULTS:
| 115 | 113 | 114 | 116 |

#+BEGIN_SRC emacs-lisp 
 (remove-couple 112)  
#+END_SRC

#+RESULTS:
| 115 | 113 | 114 | 116 | 112 |
*** Step 9: Find Next Majority
#+BEGIN_SRC emacs-lisp 
      (loop for row in (cdr dance-totals-columns)
            collect (find-number-of-majorities row))
#+END_SRC

#+RESULTS:
| (117 . 3) |           |
| (117 . 5) |           |
| (111 . 5) | (117 . 5) |

*** Step 10: Single Majority
#+BEGIN_SRC emacs-lisp 
 (remove-couple 117)  
#+END_SRC

#+RESULTS:
| 115 | 113 | 114 | 116 | 112 | 117 |

*** Step 12: Find LAST MAJORITY
#+BEGIN_SRC emacs-lisp 
      (loop for row in (cdr dance-totals-columns)
            collect (find-number-of-majorities row))
#+END_SRC

#+RESULTS:
| (111 . 5) |

#+BEGIN_SRC emacs-lisp 
 (remove-couple 111)  
#+END_SRC

#+RESULTS:
| 115 | 113 | 114 | 116 | 112 | 117 | 111 |

*** Step 13: Print Scores
   #+BEGIN_SRC emacs-lisp
   (print-standings places)
#+END_SRC 

#+RESULTS:
| 1 | 115 |
| 2 | 113 |
| 3 | 114 |
| 4 | 116 |
| 5 | 112 |
| 6 | 117 |
| 7 | 111 |

*** Test UI
  Judges:
  [ ] 3
  [x] 5
  [ ] 7
  [ ] 9

  #+name: couple-number
  6
 
  #+name: number-of-dances
  5

**** Dance 1: Cha-Cha


   #+name: d
   | Number of Dances | 5 |   |
   | Random text      |   |   |
   
   #+BEGIN_SRC elisp :var d=d  
   (loop for x from 1 to (cadr (first d))
           collect d)
   #+END_SRC

   #+RESULTS:
   | (Number of Dances 5 ) | (Random text  ) |
   | (Number of Dances 5 ) | (Random text  ) |
   | (Number of Dances 5 ) | (Random text  ) |
   | (Number of Dances 5 ) | (Random text  ) |
   | (Number of Dances 5 ) | (Random text  ) |
   |                       |                 |
   
