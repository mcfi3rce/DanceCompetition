* Development:
** Useful functions:
*** Transpose Function
 #+BEGIN_SRC emacs-lisp :results silent
   (defun transpose (list-of-same-size-lists)
     (apply 'mapcar* 'list list-of-same-size-lists))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp :results raw
   (let ((flipped-lists (transpose '((1 2 3) (4 5 6)))))
     (remove (second flipped-lists) flipped-lists))
 #+END_SRC

 #+RESULTS:
 ((1 4) (3 6))
 ((1 4) (3 6))
 ((1 4) (3 6))
 ((1 4) (3 6))

 #+BEGIN_SRC emacs-lisp :results value :var totals=totals
   (transpose totals)
 #+END_SRC

 #+RESULTS:
 | 0 | 0 | 0 | 0 | 0 | 0 | 5 | 0 |
 | 0 | 0 | 1 | 2 | 0 | 2 | 0 | 0 |
 | 1 | 1 | 1 | 0 | 2 | 0 | 0 | 0 |
 | 1 | 0 | 2 | 1 | 1 | 0 | 0 | 0 |
 | 2 | 3 | 0 | 0 | 0 | 0 | 0 | 0 |
 | 1 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |
 | 0 | 1 | 0 | 1 | 1 | 2 | 0 | 0 |

*** ++ Function:
 #+BEGIN_SRC emacs-lisp
   (defun ++ (l1 l2)
     (mapcar* '+ l1 l2))
 #+END_SRC

 #+RESULTS:
 : ++

** Initial values for the Dance:
 #+tblname: dances
 | Couple | 	A | 	B | 	C | 	D | 	E | 	F | 	G | 	H |
 |--------+-----+-----+-----+-----+-----+-----+-----+-----|
 |    111 |   7 |   7 |   7 |   7 |   7 |     |     |     |
 |    112 |   4 |   6 |   3 |   6 |   4 |     |     |     |
 |    113 |   1 |   5 |   2 |   3 |   5 |     |     |     |
 |    114 |   3 |   3 |   4 |   5 |   1 |     |     |     |
 |    115 |   2 |   1 |   1 |   2 |   2 |     |     |     |
 |    116 |   5 |   4 |   6 |   1 |   3 |     |     |     |
 |    117 |   6 |   2 |   5 |   4 |   6 |     |     |     |

 #+BEGIN_SRC emacs-lisp :var dances=dances :results silent
   (defun calculate-majority (row)
     (1+ (/ (length (remove-if 'stringp row)) 2)))

   (setq dancers (mapcar 'first dances)
         dancers-line (append `(,dancers hline))
         dancer-scores (mapcar (lambda (row)
                                 (loop for score in (remove-if 'stringp row)
                                       collect score))
                               dances)
         majority (calculate-majority (cdr (first dances)))
         place 1)
 #+END_SRC

** Extract the place values for each of the dances:
 #+name: totals
 #+BEGIN_SRC emacs-lisp :var dances=dances :results value
   (defun extract-place (n dances)
     (mapcar (lambda (row)
               (loop for score in (remove-if 'stringp row)
                     count (= n score)))
             dances))

   (append dancers-line 
           (loop for place from 1 to 8
                 collect (extract-place place dances)))
 #+END_SRC

 #+RESULTS: totals
 | 111 | 112 | 113 | 114 | 115 | 116 | 117 |
 |-----+-----+-----+-----+-----+-----+-----|
 |   0 |   0 |   1 |   1 |   2 |   1 |   0 |
 |   0 |   0 |   1 |   0 |   3 |   0 |   1 |
 |   0 |   1 |   1 |   2 |   0 |   1 |   0 |
 |   0 |   2 |   0 |   1 |   0 |   1 |   1 |
 |   0 |   0 |   2 |   1 |   0 |   1 |   1 |
 |   0 |   2 |   0 |   0 |   0 |   1 |   2 |
 |   5 |   0 |   0 |   0 |   0 |   0 |   0 |
 |   0 |   0 |   0 |   0 |   0 |   0 |   0 |

** Calculate the number of place values for each place:
 #+name: totals-row
 #+BEGIN_SRC emacs-lisp :var totals=totals
   (setq first (first totals)
           second (++ first (second totals))
           third (++ second (third totals))
           fourth (++ third (fourth totals))
           fifth (++ fourth (fifth totals))
           sixth (++ fifth  (sixth totals))
           seventh (++ sixth (seventh totals))
           all (list first second third fourth fifth sixth seventh)
           dance-totals-column (append (list dancers) all)
           dance-totals-row (transpose (append (list dancers)
                                               (loop with sum-row = (make-list (length (first totals)) 0)
                                                     for row in (butlast totals)
                                                     do (setq sum-row (++ row sum-row))
                                                     collect sum-row))))
 #+END_SRC

 #+RESULTS: totals-row
 | 111 | 0 | 0 | 0 | 0 | 0 | 0 | 5 |
 | 112 | 0 | 0 | 1 | 3 | 3 | 5 | 5 |
 | 113 | 1 | 2 | 3 | 3 | 5 | 5 | 5 |
 | 114 | 1 | 1 | 3 | 4 | 5 | 5 | 5 |
 | 115 | 2 | 5 | 5 | 5 | 5 | 5 | 5 |
 | 116 | 1 | 1 | 2 | 3 | 4 | 5 | 5 |
 | 117 | 0 | 1 | 1 | 2 | 3 | 5 | 5 |
 ((111 0 0 0 0 0 0 5) (112 0 0 1 3 3 5 5) (113 1 2 3 3 5 5 5) (114 1 1 3 4 5 5 5) (115 2 5 5 5 5 5 5) (116 1 1 2 3 4 5 5) (117 0 1 1 2 3 5 5))
 ((111 0 0 0 0 0 0 5) (112 0 0 1 3 3 5 5) (113 1 2 3 3 5 5 5) (114 1 1 3 4 5 5 5) (115 2 5 5 5 5 5 5) (116 1 1 2 3 4 5 5) (117 0 1 1 2 3 5 5))
 ((111 0 0 0 0 0 0 5) (112 0 0 1 3 3 5 5) (113 1 2 3 3 5 5 5) (114 1 1 3 4 5 5 5) (115 2 5 5 5 5 5 5) (116 1 1 2 3 4 5 5) (117 0 1 1 2 3 5 5))

 #+RESULTS: totals-column
 | 111 | 0 | 0 | 0 | 0 | 0 | 0 | 5 |
 | 112 | 0 | 0 | 1 | 3 | 3 | 5 | 5 |
 | 113 | 1 | 2 | 3 | 3 | 5 | 5 | 5 |
 | 114 | 1 | 1 | 3 | 4 | 5 | 5 | 5 |
 | 115 | 2 | 5 | 5 | 5 | 5 | 5 | 5 |
 | 116 | 1 | 1 | 2 | 3 | 4 | 5 | 5 |
 | 117 | 0 | 1 | 1 | 2 | 3 | 5 | 5 |

** Find-number-of-majorities Iterative Version:
#+BEGIN_SRC emacs-lisp :results silent
  (defun find-number-of-majorities (row)
     (pos(loop 
      for value in row
      for position from 0
      when (>= value majority) 
      collect (cons position value)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (find-number-of-majorities third)
#+END_SRC

#+RESULTS:
: ((2 . 3) (3 . 3) (4 . 5))

** Converts the majorities to dance numbers
#+BEGIN_SRC emacs-lisp :results silent
  (defun position-to-dancers (tied-dancers)
    (mapcar (lambda (x) (elt dancers (car x))) tied-dancers))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results raw
  (position-to-dancers (find-number-of-majorities third))
#+END_SRC

#+RESULTS:
(113 114 115)

** TODO Finds largest majority
   : This needs work because it doesn't handle tied majorities
  #+BEGIN_SRC emacs-lisp :results output
    (defun largest-majority (tied-dancers)
       (list (mapca (apply 'tieable-max (mapcar 'cdr tied-dancers)) tied-dancers)))
    (defun tieable-max (win-values)
      (loop for majority in (butlast (sort win-values '>))
            for next-majority in (rest (sort win-values '>))
            when (> majority next-majority)
            return majority
            when (= majority next-majority)
            return (remove-if-not (lambda (x) (= majority x)) win-values)))
#+END_SRC 

#+RESULTS:
(113 114 115)
#+BEGIN_SRC emacs-lisp 
 (largest-majority '((2 . 3) (3 . 3) (4 . 5))) 
#+END_SRC

#+RESULTS:
: 4

** Remove dancer after placement:
#+BEGIN_SRC emacs-lisp :results silent 
  (defun remove-couple (couple)
    (setq dance-totals-row (remove (elt totals-row (position couple dancers)) dance-totals-row))
    (setf (elt dancers (position couple dancers)) place)
    (incf place))
#+END_SRC

#+BEGIN_SRC emacs-lisp  :var totals-row=totals-row
  (remove-couple 115) 
#+END_SRC

#+RESULTS:
: 2
4

 : After the dancer is removed
#+BEGIN_SRC emacs-lisp :results value 
  (list dance-totals-row dancers)
#+END_SRC

#+RESULTS:
| (111 0 0 0 0 0 0 5) | (112 0 0 1 3 3 5 5) | (113 1 2 3 3 5 5 5) | (114 1 1 3 4 5 5 5) | (116 1 1 2 3 4 5 5) | (117 0 1 1 2 3 5 5) |     |
|                 111 |                 112 |                 113 |                 114 |                   1 |                 116 | 117 |

   I removed the code I was working on because I realized a test sequence of individual functions would be more informative:
   First Function:
** DONE ADD GET SCORE FOR COUPLE NUMBER
   CLOSED: [2018-02-28 Wed 17:58]
 #+BEGIN_SRC emacs-lisp :results silent
   (defun get-score (couple-number)
     (loop for row in dancer-scores
           when (= (car row) couple-number)
           return (rest row)))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
   (get-score 111)
 #+END_SRC

 #+RESULTS:
 | 7 | 7 | 7 | 7 | 7 |

** DONE ADD GET SUM OF VALUES OF PLACES UNDER A CERTAIN PLACE EX: values of scores from 1-3
   CLOSED: [2018-02-28 Wed 18:05]
 #+BEGIN_SRC emacs-lisp :results silent
   (defun sum-of-values-at-place (couple place)
     (loop for value in (get-score couple)
           when (<= value place)
           sum value))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp 
   dancer-scores
 #+END_SRC

 #+RESULTS:
 | 111 | 7 | 7 | 7 | 7 | 7 |
 | 112 | 4 | 6 | 3 | 6 | 4 |
 | 113 | 1 | 5 | 2 | 3 | 5 |
 | 114 | 3 | 3 | 4 | 5 | 1 |
 | 115 | 2 | 1 | 1 | 2 | 2 |
 | 116 | 5 | 4 | 6 | 1 | 3 |
 | 117 | 6 | 2 | 5 | 4 | 6 |

 #+BEGIN_SRC emacs-lisp 
   (sum-of-values-at-place 113 3)
 #+END_SRC

 #+RESULTS:
 : 6
** DONE Compare two couples and return the couple with the lowest
   CLOSED: [2018-02-28 Wed 18:43]
   compare-sums takes in two couples and a place value and returns the couple with the lowest sum.
   If the value of the sums is the same then it returns both couples 
 #+BEGIN_SRC emacs-lisp :results silent
   (defun compare-sums (couple1 couple2 place)
     (cond ((< (sum-of-values-at-place couple1 place)
               (sum-of-values-at-place couple2 place)) couple1)
           ((> (sum-of-values-at-place couple1 place)
               (sum-of-values-at-place couple2 place)) couple2)
           (t (list couple1 couple2))))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
   (compare-sums 113 114 3)
 #+END_SRC

 #+RESULTS:
 | 113 | 114 |

** TODO HANDLE TIE BREAK VALUES
 #+BEGIN_SRC emacs-lisp :results silent
 
 #+END_SRC

* Testing:
  *Evaluate this before testing*
** Data:
 #+tblname: dances
 | Couple | 	A | 	B | 	C | 	D | 	E | 	F | 	G | 	H |
 |--------+-----+-----+-----+-----+-----+-----+-----+-----|
 |    111 |   7 |   7 |   7 |   7 |   7 |     |     |     |
 |    112 |   4 |   6 |   3 |   6 |   4 |     |     |     |
 |    113 |   1 |   5 |   2 |   3 |   5 |     |     |     |
 |    114 |   3 |   3 |   4 |   5 |   1 |     |     |     |
 |    115 |   2 |   1 |   1 |   2 |   2 |     |     |     |
 |    116 |   5 |   4 |   6 |   1 |   3 |     |     |     |
 |    117 |   6 |   2 |   5 |   4 |   6 |     |     |     |

#+name: totals-rows
 #+BEGIN_SRC emacs-lisp :var dances=dances :results value
      (defun calculate-majority (row)
        (1+ (/ (length (remove-if 'stringp row)) 2)))
      (defun transpose (list-of-same-size-lists)
        (apply 'mapcar* 'list list-of-same-size-lists))
      (defun ++ (l1 l2)
        (mapcar* '+ l1 l2))
      (defun extract-place (n dances)
        (mapcar (lambda (row)
                  (loop for score in (remove-if 'stringp row)
                        count (= n score)))
                dances))
      (setq dancers (mapcar 'first dances)
            dancers-line (append `(,dancers hline))
            dancer-scores (mapcar (lambda (row)
                                    (loop for score in (remove-if 'stringp row)
                                          collect score))
                                  dances)
            majority (calculate-majority (cdr (first dances)))
            place 1
            totals (loop for place from 1 to 8
                         collect (extract-place place dances))
            first (first totals)
            second (++ first (second totals))
            third (++ second (third totals))
            fourth (++ third (fourth totals))
            fifth (++ fourth (fifth totals))
            sixth (++ fifth  (sixth totals))
            seventh (++ sixth (seventh totals))
            all (list first second third fourth fifth sixth seventh)
            dance-totals-column (append (list dancers) all)
            dance-totals-row (transpose (append (list dancers)
                                                (loop with sum-row = (make-list (length (first totals)) 0)
                                                      for row in (butlast totals)
                                                            do (setq sum-row (++ row sum-row))
                                                            collect sum-row))))
 #+END_SRC

 #+RESULTS: totals-rows
 | 111 | 0 | 0 | 0 | 0 | 0 | 0 | 5 |
 | 112 | 0 | 0 | 1 | 3 | 3 | 5 | 5 |
 | 113 | 1 | 2 | 3 | 3 | 5 | 5 | 5 |
 | 114 | 1 | 1 | 3 | 4 | 5 | 5 | 5 |
 | 115 | 2 | 5 | 5 | 5 | 5 | 5 | 5 |
 | 116 | 1 | 1 | 2 | 3 | 4 | 5 | 5 |
 | 117 | 0 | 1 | 1 | 2 | 3 | 5 | 5 |

  *Next evaluate the functions next*
** Functions:
#+BEGIN_SRC emacs-lisp :results silent :var totals-row=totals-rows
  (defun find-number-of-majorities (row)
      (pos(loop 
           for value in row
           for position from 0
           when (>= value majority) 
           collect (cons position value))))

  (defun position-to-dancers (tied-dancers)
    (mapcar (lambda (x) (elt dancers (car x))) tied-dancers))

  (defun largest-majority (tied-dancers)
    (list (mapca (apply 'tieable-max (mapcar 'cdr tied-dancers)) tied-dancers)))

  (defun tieable-max (win-values)
    (loop for majority in (butlast (sort win-values '>))
          for next-majority in (rest (sort win-values '>))
          when (> majority next-majority)
          return majority
          when (= majority next-majority)
          return (remove-if-not (lambda (x) (= majority x)) win-values)))

  (defun remove-couple (couple)
       (setq dance-totals-row (remove (elt totals-row (position couple dancers)) dance-totals-row))
       (setf (elt dancers (position couple dancers)) place)
       (incf place))

(defun get-score (couple-number)
     (loop for row in dancer-scores
           when (= (car row) couple-number)
           return (rest row)))

 (defun sum-of-values-at-place (couple place)
     (loop for value in (get-score couple)
           when (<= value place)
           sum value))

(defun compare-sums (couple1 couple2 place)
     (cond ((< (sum-of-values-at-place couple1 place)
               (sum-of-values-at-place couple2 place)) couple1)
           ((> (sum-of-values-at-place couple1 place)
               (sum-of-values-at-place couple2 place)) couple2)
           (t (list couple1 couple2))))
 #+END_SRC 
#+END_SRC
** Test:
*** This will follow the way the final code will be evaluated:
