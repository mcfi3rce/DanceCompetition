* Useful functions:
** Transpose Function
#+BEGIN_SRC emacs-lisp :results silent
  (defun transpose (list-of-same-size-lists)
    (apply 'mapcar* 'list list-of-same-size-lists))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results raw
  (let ((flipped-lists (transpose '((1 2 3) (4 5 6)))))
    (remove (second flipped-lists) flipped-lists))
#+END_SRC

#+RESULTS:
((1 4) (3 6))

#+BEGIN_SRC emacs-lisp :results value :var totals=totals
  (transpose totals)
#+END_SRC

#+RESULTS:
| 0 | 0 | 0 | 0 | 0 | 0 | 5 | 0 |
| 0 | 0 | 1 | 2 | 0 | 2 | 0 | 0 |
| 1 | 1 | 1 | 0 | 2 | 0 | 0 | 0 |
| 1 | 0 | 2 | 1 | 1 | 0 | 0 | 0 |
| 2 | 3 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |
| 0 | 1 | 0 | 1 | 1 | 2 | 0 | 0 |

* Initial values for the Dance:
#+tblname: dances
| Couple | 	A | 	B | 	C | 	D | 	E | 	F | 	G | 	H |
|--------+-----+-----+-----+-----+-----+-----+-----+-----|
|    111 |   7 |   7 |   7 |   7 |   7 |     |     |     |
|    112 |   4 |   6 |   3 |   6 |   4 |     |     |     |
|    113 |   1 |   5 |   2 |   3 |   5 |     |     |     |
|    114 |   3 |   3 |   4 |   5 |   1 |     |     |     |
|    115 |   2 |   1 |   1 |   2 |   2 |     |     |     |
|    116 |   5 |   4 |   6 |   1 |   3 |     |     |     |
|    117 |   6 |   2 |   5 |   4 |   6 |     |     |     |

#+BEGIN_SRC emacs-lisp :var dances=dances :results silent
  (defun calculate-majority (row)
    (1+ (/ (length (remove-if 'stringp row)) 2)))

  (setq dancers (mapcar 'first dances)
        dancers-line (append `(,dancers hline))
        dancer-scores (mapcar (lambda (row)
                                (loop for score in (remove-if 'stringp row)
                                      collect score))
                              dances)
        majority (calculate-majority (cdr (first dances)))
        place 1)
#+END_SRC

* Extract the place values for each of the dances:
#+name: totals
#+BEGIN_SRC emacs-lisp :var dances=dances :results value
  (defun extract-place (n dances)
    (mapcar (lambda (row)
              (loop for score in (remove-if 'stringp row)
                    count (= n score)))
            dances))

  (append dancers-line 
          (loop for place from 1 to 8
                collect (extract-place place dances)))
#+END_SRC

#+RESULTS: totals
| 111 | 112 | 113 | 114 | 115 | 116 | 117 |
|-----+-----+-----+-----+-----+-----+-----|
|   0 |   0 |   1 |   1 |   2 |   1 |   0 |
|   0 |   0 |   1 |   0 |   3 |   0 |   1 |
|   0 |   1 |   1 |   2 |   0 |   1 |   0 |
|   0 |   2 |   0 |   1 |   0 |   1 |   1 |
|   0 |   0 |   2 |   1 |   0 |   1 |   1 |
|   0 |   2 |   0 |   0 |   0 |   1 |   2 |
|   5 |   0 |   0 |   0 |   0 |   0 |   0 |
|   0 |   0 |   0 |   0 |   0 |   0 |   0 |

* Calculate the number of place values for each place:
#+BEGIN_SRC emacs-lisp :var totals=totals
  (defun ++ (l1 l2)
    (mapcar* '+ l1 l2))

  (setq first (first totals)
          second (++ first (second totals))
          third (++ second (third totals))
          fourth (++ third (fourth totals))
          fifth (++ fourth (fifth totals))
          sixth (++ fifth  (sixth totals))
          seventh (++ sixth (seventh totals))
          all (list first second third fourth fifth sixth seventh))
          dance-totals-row (transpose (append (list dancers)
                                              (loop with sum-row = (make-list (length (first totals)) 0)
                                                    for row in (butlast totals)
                                                    do (setq sum-row (++ row sum-row))
                                                    collect sum-row)))
  dance-totals-column (append (list dancers) all)
#+END_SRC

#+RESULTS:
| 111 | 112 | 113 | 114 | 115 | 116 | 117 |
|   0 |   0 |   1 |   1 |   2 |   1 |   0 |
|   0 |   0 |   2 |   1 |   5 |   1 |   1 |
|   0 |   1 |   3 |   3 |   5 |   2 |   1 |
|   0 |   3 |   3 |   4 |   5 |   3 |   2 |
|   0 |   3 |   5 |   5 |   5 |   4 |   3 |
|   0 |   5 |   5 |   5 |   5 |   5 |   5 |
|   5 |   5 |   5 |   5 |   5 |   5 |   5 |

* Beginning of the find winner code *lots* to do: 
** Find-majority Mapping version:
#+BEGIN_SRC emacs-lisp :results raw
  ;; Testing first place 
  (defun find-winner (row)
    (catch 'dancer
      (mapcar (lambda (x)
                (if (>= x majority)
                    (throw 'dancer (position x row)))) row)))
(elt dancers (find-winner third))
#+END_SRC

#+RESULTS:
113

** Find-majority Iterative Version:
#+BEGIN_SRC emacs-lisp :results silent
  (defun find-number-of-majorities (row)
     (loop for value in row
           for position from 0
           when (>= value majority) 
           collect position)) 
#+END_SRC

#+BEGIN_SRC emacs-lisp :results raw
  (find-number-of-majorities third)
#+END_SRC

#+RESULTS:
(2 3 4)

** Remove dancer after placement:
#+BEGIN_SRC emacs-lisp :results silent
  (defun remove-couple (couple)
    (replace (elt dance-totals-row couple) place)
    (incf place))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results raw
 (remove-couple (position 111 dancers)) 
#+END_SRC

 : After the dancer is removed
#+BEGIN_SRC emacs-lisp :results value
  dance-totals-row
#+END_SRC
#+RESULTS:
